diff --git a/ngx_http_upstream_ntlm_module.c b/ngx_http_upstream_ntlm_module.c
index 0000000..1111111 100644
--- a/ngx_http_upstream_ntlm_module.c
+++ b/ngx_http_upstream_ntlm_module.c
@@ -1,3 +1,4 @@
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_http.h>
+ #include "src/ntlm_abort.h"
@@
 typedef struct {
     ngx_http_upstream_ntlm_srv_conf_t  *conf;
     ngx_queue_t                         queue;
     ngx_connection_t                   *peer_connection;
     ngx_connection_t                   *client_connection;
+    unsigned                            client_closed:1;   /* A3: mark client abort */
+    unsigned                            queued_in_cache:1; /* A3: guard double-remove */
 } ngx_http_upstream_ntlm_cache_t;
@@
 static ngx_int_t
 ngx_http_upstream_init_ntlm(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
 {
@@
-        cached[i].conf = hncf;
+        cached[i].conf = hncf;
+        cached[i].client_closed   = 0; /* A3 init */
+        cached[i].queued_in_cache = 0; /* A3 init */
@@
 static ngx_int_t
 ngx_http_upstream_init_ntlm_peer(ngx_http_request_t *r, ngx_http_upstream_srv_conf_t *us)
 {
@@
     hnpd->client_connection = r->connection;
+    /* A1: register abort-cleanup early (upstream may not be connected yet) */
+    (void) ngx_http_ntlm_abort_register(r, NULL);
@@
 static ngx_int_t
 ngx_http_upstream_get_ntlm_peer(ngx_peer_connection_t *pc, void *data)
 {
@@
-            ngx_queue_remove(q);
-            ngx_queue_insert_head(&hndp->conf->free, q);
+            ngx_queue_remove(q);
+            item->queued_in_cache = 0; /* A3 */
+            ngx_queue_insert_head(&hndp->conf->free, q);
@@
 found:
@@
     pc->connection = c;
     pc->cached = 1;
+    /* A1: now we have upstream peer connection -> update cleanup ctx */
+    (void) ngx_http_ntlm_abort_update(hndp->upstream->request, pc->connection);
     return NGX_DONE;
 }
@@
 static void
 ngx_http_upstream_free_ntlm_peer(ngx_peer_connection_t *pc, void *data, ngx_uint_t state)
 {
@@
     if (ngx_queue_empty(&hndp->conf->free)) {
         q = ngx_queue_last(&hndp->conf->cache);
         ngx_queue_remove(q);
         item = ngx_queue_data(q, ngx_http_upstream_ntlm_cache_t, queue);
         ngx_http_upstream_ntlm_close(item->peer_connection);
         item->peer_connection = NULL;
-    } else {
+        item->client_closed   = 0;     /* A3 */
+        item->queued_in_cache = 0;     /* A3 */
+    } else {
         q = ngx_queue_head(&hndp->conf->free);
         ngx_queue_remove(q);
         item = ngx_queue_data(q, ngx_http_upstream_ntlm_cache_t, queue);
     }
-    ngx_queue_insert_head(&hndp->conf->cache, q);
+    ngx_queue_insert_head(&hndp->conf->cache, q);
+    item->queued_in_cache = 1;         /* A3: track that we're in cache list */
     item->peer_connection = c;
     item->client_connection = hndp->client_connection;
+    item->client_closed = 0;           /* A3 reset */
@@
-    for (cln = item->client_connection->pool->cleanup; cln; cln = cln->next) {
+    for (cln = item->client_connection->pool->cleanup; cln; cln = cln->next) {
         if (cln->handler == ngx_http_upstream_client_conn_cleanup) {
             cleanup_item = cln->data;
             break;
         }
     }
@@
 static void
 ngx_http_upstream_client_conn_cleanup(void *data)
 {
     ngx_http_upstream_ntlm_cache_t *item = data;
-    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
-                   "ntlm client connection closed %p, signaling peer connection %p",
-                   item->client_connection, item->peer_connection);
-
-    if (item->peer_connection != NULL) {
-        /* move to free list and close here -> RISK of double remove elsewhere */
-        ngx_queue_remove(&item->queue);
-        ngx_queue_insert_head(&item->conf->free, &item->queue);
-        ngx_http_upstream_ntlm_close(item->peer_connection);
-        item->peer_connection = NULL;
-    }
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,
+                   "ntlm client closed %p, posting close for upstream %p",
+                   item->client_connection, item->peer_connection);
+    if (item->peer_connection != NULL) {
+        item->client_closed = 1;                   /* A1/A3: mark abort */
+        item->peer_connection->read->timedout = 1; /* force close-handler path */
+        ngx_post_event(item->peer_connection->read, &ngx_posted_events);
+    }
 }
@@
 static void
 ngx_http_upstream_ntlm_close_handler(ngx_event_t *ev)
 {
@@
-    item = c->data;
-    conf = item->conf;
+    item = c->data;
+    conf = item->conf;
@@
-    /* previous code touched queues in multiple places */
-    ngx_http_upstream_ntlm_close(c);
+    /* A2/A3: single place to manipulate queues & close connection */
+    item->peer_connection = NULL;                /* cut link so cleanup won't repost */
+    if (item->queued_in_cache) {
+        ngx_queue_remove(&item->queue);
+        item->queued_in_cache = 0;
+        ngx_queue_insert_head(&conf->free, &item->queue);
+    }
+    ngx_http_upstream_ntlm_close(c);
+    item->client_closed = 0; /* clear flag */
 }